# Auto-generated by compose2nix.

{ pkgs, lib, config, ... }:

{
  # Runtime
  virtualisation.podman = {
    enable = true;
    autoPrune.enable = true;
    dockerCompat = true;
  };

  # Enable container name DNS for all Podman networks.
  networking.firewall.interfaces = let
    matchAll = if !config.networking.nftables.enable then "podman+" else "podman*";
  in {
    "${matchAll}".allowedUDPPorts = [ 53 ];
  };

  virtualisation.oci-containers.backend = "podman";

  # Containers
  virtualisation.oci-containers.containers."wanderer-db" = {
    image = "flomp/wanderer-db";
    environment = {
      "MEILI_MASTER_KEY" = "vODkljPcfFANYNepCHyDyGjzAMPcdHnrb6X5KyXQPWo";
      "MEILI_URL" = "http://search:7700";
      "ORIGIN" = "http://localhost:3000";
      "POCKETBASE_ENCRYPTION_KEY" = "fde406459dc1f6ca6f348e1f44a9a2af";
    };
    volumes = [
      "/var/lib/wanderer/data/pb_data:/pb_data:rw"
    ];
    ports = [
      "8090:8090/tcp"
    ];
    dependsOn = [
      "wanderer-search"
    ];
    log-driver = "journald";
    extraOptions = [
      "--health-cmd=wget --spider -q http://localhost:8090/health || exit 1"
      "--health-interval=15s"
      "--health-retries=10"
      "--health-start-period=20s"
      "--health-timeout=10s"
      "--network-alias=db"
      "--network=wanderer_wanderer"
    ];
  };
  systemd.services."podman-wanderer-db" = {
    serviceConfig = {
      Restart = lib.mkOverride 90 "always";
    };
    after = [
      "podman-network-wanderer_wanderer.service"
    ];
    requires = [
      "podman-network-wanderer_wanderer.service"
    ];
    partOf = [
      "podman-compose-wanderer-root.target"
    ];
    wantedBy = [
      "podman-compose-wanderer-root.target"
    ];
  };
  virtualisation.oci-containers.containers."wanderer-search" = {
    image = "getmeili/meilisearch:v1.11.3";
    environment = {
      "MEILI_MASTER_KEY" = "vODkljPcfFANYNepCHyDyGjzAMPcdHnrb6X5KyXQPWo";
      "MEILI_NO_ANALYTICS" = "true";
      "MEILI_URL" = "http://search:7700";
    };
    volumes = [
      "/var/lib/wanderer/data/data.ms:/meili_data/data.ms:rw"
    ];
    ports = [
      "7700:7700/tcp"
    ];
    log-driver = "journald";
    extraOptions = [
      "--health-cmd=curl --fail http://localhost:7700/health || exit 1"
      "--health-interval=15s"
      "--health-retries=10"
      "--health-start-period=20s"
      "--health-timeout=10s"
      "--network-alias=search"
      "--network=wanderer_wanderer"
    ];
  };
  systemd.services."podman-wanderer-search" = {
    serviceConfig = {
      Restart = lib.mkOverride 90 "always";
    };
    after = [
      "podman-network-wanderer_wanderer.service"
    ];
    requires = [
      "podman-network-wanderer_wanderer.service"
    ];
    partOf = [
      "podman-compose-wanderer-root.target"
    ];
    wantedBy = [
      "podman-compose-wanderer-root.target"
    ];
  };
  virtualisation.oci-containers.containers."wanderer-web" = {
    image = "flomp/wanderer-web";
    environment = {
      "BODY_SIZE_LIMIT" = "Infinity";
      "MEILI_MASTER_KEY" = "vODkljPcfFANYNepCHyDyGjzAMPcdHnrb6X5KyXQPWo";
      "MEILI_URL" = "http://search:7700";
      "ORIGIN" = "https://wanderer.keidel.me";
      "PUBLIC_DISABLE_SIGNUP" = "true";
      "PUBLIC_NOMINATIM_URL" = "https://nominatim.openstreetmap.org";
      "PUBLIC_OVERPASS_API_URL" = "https://overpass-api.de";
      "PUBLIC_POCKETBASE_URL" = "http://db:8090";
      "PUBLIC_VALHALLA_URL" = "https://valhalla1.openstreetmap.de";
      "UPLOAD_FOLDER" = "/app/uploads";
    };
    volumes = [
      "/var/lib/wanderer/data/uploads:/app/uploads:rw"
    ];
    ports = [
      "3000:3000/tcp"
    ];
    dependsOn = [
      "wanderer-db"
      "wanderer-search"
    ];
    log-driver = "journald";
    extraOptions = [
      "--health-cmd=curl --fail http://localhost:3000/ || exit 1"
      "--health-interval=15s"
      "--health-retries=10"
      "--health-start-period=20s"
      "--health-timeout=10s"
      "--network-alias=web"
      "--network=wanderer_wanderer"
    ];
  };
  systemd.services."podman-wanderer-web" = {
    serviceConfig = {
      Restart = lib.mkOverride 90 "always";
    };
    after = [
      "podman-network-wanderer_wanderer.service"
    ];
    requires = [
      "podman-network-wanderer_wanderer.service"
    ];
    partOf = [
      "podman-compose-wanderer-root.target"
    ];
    wantedBy = [
      "podman-compose-wanderer-root.target"
    ];
  };

  # Networks
  systemd.services."podman-network-wanderer_wanderer" = {
    path = [ pkgs.podman ];
    serviceConfig = {
      Type = "oneshot";
      RemainAfterExit = true;
      ExecStop = "podman network rm -f wanderer_wanderer";
    };
    script = ''
      podman network inspect wanderer_wanderer || podman network create wanderer_wanderer --driver=bridge
    '';
    partOf = [ "podman-compose-wanderer-root.target" ];
    wantedBy = [ "podman-compose-wanderer-root.target" ];
  };

  # Root service
  # When started, this will automatically create all resources and start
  # the containers. When stopped, this will teardown all resources.
  systemd.targets."podman-compose-wanderer-root" = {
    unitConfig = {
      Description = "Root target generated by compose2nix.";
    };
    wantedBy = [ "multi-user.target" ];
  };

  services.nginx.virtualHosts."wanderer.keidel.me" = {
    forceSSL = true;
    enableACME = true;
    locations."/" = {
      proxyPass = "http://127.0.0.1:3000";
      proxyWebsockets = true;
      extraConfig = ''
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
      '';
    };
  };
}
